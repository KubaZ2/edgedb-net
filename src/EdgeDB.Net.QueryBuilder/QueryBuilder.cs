using EdgeDB.Interfaces;
using EdgeDB.Interfaces.Queries;
using EdgeDB.QueryNodes;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using System.Threading.Tasks;

namespace EdgeDB
{
    public class QueryBuilder<TType> : IQueryBuilder<TType>
    {
        private readonly List<QueryNode> _nodes;
        private QueryNode? CurrentUserNode => _nodes.LastOrDefault(x => !x.IsAutoGenerated);
        private readonly Dictionary<string, object?> _queryGlobals;
        
        static QueryBuilder()
        {
            QueryObjectManager.Initialize();
        }

        internal QueryBuilder()
        {
            _nodes = new();
            _queryGlobals = new();
        }

        internal QueryBuilder(List<QueryNode> nodes, Dictionary<string, object?> globals)
        {
            _nodes = nodes;
            _queryGlobals = globals;
        }

        private QueryBuilder<TTarget> EnterNewType<TTarget>()
            => new(_nodes, _queryGlobals);

        private TNode AddNode<TNode>(NodeContext context, bool autoGenerated = false)
            where TNode : QueryNode
        {
            // create the node and a builder
            var builder = new NodeBuilder(context, _queryGlobals, _nodes)
            {
                IsAutoGenerated = autoGenerated
            };
            
            var node = (TNode)Activator.CreateInstance(typeof(TNode), builder)!;

            // visit the node
            node.Visit();

            _nodes.Add(node);

            return node;
        }

        public (string Query, IDictionary<string, object?> Parameters) Build()
        {
            List<string> query = new();
            List<IDictionary<string, object?>> parameters = new();

            var nodes = _nodes;

            foreach(var node in nodes)
                node.FinalizeQuery();
            
            // create a with block if we have any query globals
            if (_queryGlobals.Any())
            {
                var with = new WithNode(new NodeBuilder(new WithContext(typeof(TType))
                {
                    Values = _queryGlobals
                }, _queryGlobals, null));
                with.Visit();
                nodes = nodes.Prepend(with).ToList();
            }

            for (int i = nodes.Count - 1; i >= 0; i--)
            {
                var node = nodes[i];

                if (node is WithNode withNode)
                {
                    if (!withNode.HasVisited)
                        withNode.Visit();
                }

                var result = node.Build();

                if (!string.IsNullOrEmpty(result.Query))
                    query.Add(result.Query);

                parameters.Add(result.Parameters);
            }

            query.Reverse();

            return (string.Join(' ', query), parameters.SelectMany(x => x).DistinctBy(x => x.Key).ToDictionary(x => x.Key, x => x.Value));
        }

        public QueryBuilder<TType> With(string name, object? value)
        {
            if (QueryObjectManager.TryGetObjectId(value, out var id))
                value = new SubQuery($"(select {value!.GetType().GetEdgeDBTypeName()} filter .id = <uuid>\"{id}\")");

            _queryGlobals[name] = value;
            return this;
        }

        #region Root nodes
        public ISelectQuery<TType> Select()
        {
            AddNode<SelectNode>(new SelectContext(typeof(TType)));
            return this;
        }

        public ISelectQuery<TNewType> Select<TNewType>(Expression<Func<TNewType>>? shape = null)
        {
            AddNode<SelectNode>(new SelectContext(typeof(TNewType))
            {
                Shape = shape
            });
            return EnterNewType<TNewType>();
        }

        public ISelectQuery<TType> Select(Expression<Func<QueryContext, TType?>> shape)
        {
            AddNode<SelectNode>(new SelectContext(typeof(TType))
            {
                Shape = shape
            });
            return this;
        }

        public ISelectQuery<TNewType> Select<TNewType>(Expression<Func<QueryContext, TNewType?>> shape)
        {
            AddNode<SelectNode>(new SelectContext(typeof(TType))
            {
                Shape = shape
            });
            return EnterNewType<TNewType>();
        }

        public IInsertQuery<TType> Insert(TType value, bool returnInsertedValue = true)
        {
            var selectedGlobal = returnInsertedValue ? QueryUtils.GenerateRandomVariableName() : null;
            AddNode<InsertNode>(new InsertContext(typeof(TType))
            {
                Value = value,
                SetAsGlobal = returnInsertedValue,
                GlobalName = selectedGlobal
            });

            if (returnInsertedValue)
            {
                AddNode<SelectNode>(new SelectContext(typeof(TType))
                {
                    SelectName = selectedGlobal,
                }, true);
            }
            
            return this;
        }

        public IInsertQuery<TType> Insert(Expression<Func<QueryContext, TType>> value, bool returnInsertedValue = true)
        {
            var selectedGlobal = returnInsertedValue ? QueryUtils.GenerateRandomVariableName() : null;
            AddNode<InsertNode>(new InsertContext(typeof(TType))
            {
                Value = value,
                SetAsGlobal = returnInsertedValue,
                GlobalName = selectedGlobal
            });

            if (returnInsertedValue)
            {
                AddNode<SelectNode>(new SelectContext(typeof(TType))
                {
                    SelectName = selectedGlobal,
                }, true);
            }

            return this;
        }

        public IUpdateQuery<TType> Update(Expression<Func<TType, TType>> updateFunc, bool returnUpdatedValue = true)
        {
            var selectedGlobal = returnUpdatedValue ? QueryUtils.GenerateRandomVariableName() : null;
            AddNode<UpdateNode>(new UpdateContext(typeof(TType))
            {
                UpdateExpression = updateFunc,
                SetAsGlobal = returnUpdatedValue,
                GlobalName = selectedGlobal
            });

            if (returnUpdatedValue)
            {
                AddNode<SelectNode>(new SelectContext(typeof(TType))
                {
                    SelectName = selectedGlobal,
                }, true);
            }
            
            return this;
        }
        
        public IDeleteQuery<TType> Delete
        {
            get
            {
                AddNode<DeleteNode>(new DeleteContext(typeof(TType)));
                return this;
            }
        }
        
        #endregion

        #region Generic sub-query methods
        private QueryBuilder<TType> Filter(LambdaExpression filter)
        {
            switch (CurrentUserNode)
            {
                case SelectNode selectNode:
                    selectNode.Filter(filter);
                    break;
                case UpdateNode updateNode:
                    updateNode.Filter(filter);
                    break;
                default:
                    throw new InvalidOperationException($"Cannot filter on a {CurrentUserNode}");
            }
            return this;
        }

        private QueryBuilder<TType> OrderBy(bool asc, LambdaExpression selector, OrderByNullPlacement? placement)
        {
            if (CurrentUserNode is not SelectNode selectNode)
                throw new InvalidOperationException($"Cannot order by on a {CurrentUserNode}");

            selectNode.OrderBy(asc, selector, placement);

            return this;
        }

        private QueryBuilder<TType> Offset(long offset)
        {
            if (CurrentUserNode is not SelectNode selectNode)
                throw new InvalidOperationException($"Cannot offset on a {CurrentUserNode}");

            selectNode.Offset(offset);

            return this;
        }

        private QueryBuilder<TType> OffsetExp(LambdaExpression offset)
        {
            if (CurrentUserNode is not SelectNode selectNode)
                throw new InvalidOperationException($"Cannot offset on a {CurrentUserNode}");

            selectNode.OffsetExpression(offset);

            return this;
        }

        private QueryBuilder<TType> Limit(long limit)
        {
            if (CurrentUserNode is not SelectNode selectNode)
                throw new InvalidOperationException($"Cannot limit on a {CurrentUserNode}");

            selectNode.Limit(limit);

            return this;
        }

        private QueryBuilder<TType> LimitExp(LambdaExpression limit)
        {
            if (CurrentUserNode is not SelectNode selectNode)
                throw new InvalidOperationException($"Cannot limit on a {CurrentUserNode}");

            selectNode.LimitExpression(limit);

            return this;
        }

        private QueryBuilder<TType> UnlessConflictOn(LambdaExpression selector)
        {
            if (CurrentUserNode is not InsertNode insertNode)
                throw new InvalidOperationException($"Cannot unless conflict on a {CurrentUserNode}");

            insertNode.UnlessConflictOn(selector);

            return this;
        }

        private QueryBuilder<TType> ElseReturnDefault()
        {
            if (CurrentUserNode is not InsertNode insertNode)
                throw new InvalidOperationException($"Cannot else return on a {CurrentUserNode}");

            insertNode.ElseDefault();

            return this;
        }

        private IQueryBuilder<object?> ElseJoint(IQueryBuilder builder)
        {
            if (CurrentUserNode is not InsertNode insertNode)
                throw new InvalidOperationException($"Cannot else on a {CurrentUserNode}");

            insertNode.Else(builder);

            return EnterNewType<object?>();
        }

        private QueryBuilder<TType> Else(Func<IQueryBuilder<TType>, IMultiCardinalityExecutable<TType>> func)
        {
            if (CurrentUserNode is not InsertNode insertNode)
                throw new InvalidOperationException($"Cannot else on a {CurrentUserNode}");

            var builder = new QueryBuilder<TType>();
            func(builder);
            insertNode.Else(builder);
            
            return this;
        }

        private QueryBuilder<TType> Else(Func<IQueryBuilder<TType>, ISingleCardinalityExecutable<TType>> func)
        {
            if (CurrentUserNode is not InsertNode insertNode)
                throw new InvalidOperationException($"Cannot else on a {CurrentUserNode}");

            var builder = new QueryBuilder<TType>();
            func(builder);
            insertNode.Else(builder);

            return this;
        }

        #endregion

        #region ISelectQuery
        ISelectQuery<TType> ISelectQuery<TType>.Filter(Expression<Func<TType, bool>> filter)
            => Filter(filter);
        ISelectQuery<TType> ISelectQuery<TType>.OrderBy(Expression<Func<TType, object?>> propertySelector, OrderByNullPlacement? nullPlacement)
            => OrderBy(true, propertySelector, nullPlacement);
        ISelectQuery<TType> ISelectQuery<TType>.OrderByDesending(Expression<Func<TType, object?>> propertySelector, OrderByNullPlacement? nullPlacement)
            => OrderBy(false, propertySelector, nullPlacement);
        ISelectQuery<TType> ISelectQuery<TType>.Offset(long offset)
            => Offset(offset);
        ISelectQuery<TType> ISelectQuery<TType>.Limit(long limit)
            => Limit(limit);
        ISelectQuery<TType> ISelectQuery<TType>.Filter(Expression<Func<TType, QueryContext, bool>> filter)
            => Filter(filter);
        ISelectQuery<TType> ISelectQuery<TType>.OrderBy(Expression<Func<TType, QueryContext, object?>> propertySelector, OrderByNullPlacement? nullPlacement)
            => OrderBy(true, propertySelector, nullPlacement);
        ISelectQuery<TType> ISelectQuery<TType>.OrderByDesending(Expression<Func<TType, QueryContext, object?>> propertySelector, OrderByNullPlacement? nullPlacement)
        => OrderBy(false, propertySelector, nullPlacement);
        ISelectQuery<TType> ISelectQuery<TType>.Offset(Expression<Func<QueryContext, long>> offset)
            => OffsetExp(offset);
        ISelectQuery<TType> ISelectQuery<TType>.Limit(Expression<Func<QueryContext, long>> limit)
            => LimitExp(limit);
        #endregion

        #region IInsertQuery
        IUnlessConflictOn<TType> IInsertQuery<TType>.UnlessConflictOn(Expression<Func<TType, object?>> propertySelector)
            => UnlessConflictOn(propertySelector);
        IUnlessConflictOn<TType> IInsertQuery<TType>.UnlessConflictOn(Expression<Func<QueryContext, TType, object?>> propertySelector)
            => UnlessConflictOn(propertySelector);
        #endregion

        #region IUpdateQuery
        IMultiCardinalityExecutable<TType> IUpdateQuery<TType>.Filter(Expression<Func<TType, bool>> filter)
            => Filter(filter);
        IMultiCardinalityExecutable<TType> IUpdateQuery<TType>.Filter(Expression<Func<QueryContext, TType, bool>> filter)
            => Filter(filter);
        #endregion

        #region IUnlessConflictOn
        ISingleCardinalityExecutable<TType> IUnlessConflictOn<TType>.ElseReturn()
            => ElseReturnDefault();
        IQueryBuilder<object?> IUnlessConflictOn<TType>.Else<TQueryBuilder>(TQueryBuilder elseQuery)
            => ElseJoint(elseQuery);
        IMultiCardinalityExecutable<TType> IUnlessConflictOn<TType>.Else(Func<IQueryBuilder<TType>, IMultiCardinalityExecutable<TType>> elseQuery)
            => Else(elseQuery);
        ISingleCardinalityExecutable<TType> IUnlessConflictOn<TType>.Else(Func<IQueryBuilder<TType>, ISingleCardinalityExecutable<TType>> elseQuery)
            => Else(elseQuery);
        #endregion

        #region IDeleteQuery
        IDeleteQuery<TType> IDeleteQuery<TType>.Filter(Expression<Func<TType, bool>> filter)
            => Filter(filter);
        IDeleteQuery<TType> IDeleteQuery<TType>.OrderBy(Expression<Func<TType, object?>> propertySelector, OrderByNullPlacement? nullPlacement)
            => OrderBy(true, propertySelector, nullPlacement);
        IDeleteQuery<TType> IDeleteQuery<TType>.OrderByDesending(Expression<Func<TType, object?>> propertySelector, OrderByNullPlacement? nullPlacement)
            => OrderBy(false, propertySelector, nullPlacement);
        IDeleteQuery<TType> IDeleteQuery<TType>.Offset(long offset)
            => Offset(offset);
        IDeleteQuery<TType> IDeleteQuery<TType>.Limit(long limit)
            => Limit(limit);
        IDeleteQuery<TType> IDeleteQuery<TType>.Filter(Expression<Func<TType, QueryContext, bool>> filter)
            => Filter(filter);
        IDeleteQuery<TType> IDeleteQuery<TType>.OrderBy(Expression<Func<TType, QueryContext, object?>> propertySelector, OrderByNullPlacement? nullPlacement)
            => OrderBy(true, propertySelector, nullPlacement);
        IDeleteQuery<TType> IDeleteQuery<TType>.OrderByDesending(Expression<Func<TType, QueryContext, object?>> propertySelector, OrderByNullPlacement? nullPlacement)
            => OrderBy(false, propertySelector, nullPlacement);
        IDeleteQuery<TType> IDeleteQuery<TType>.Offset(Expression<Func<QueryContext, long>> offset)
            => OffsetExp(offset);
        IDeleteQuery<TType> IDeleteQuery<TType>.Limit(Expression<Func<QueryContext, long>> limit)
            => LimitExp(limit);
        #endregion

        Task<IReadOnlyCollection<TType?>> IMultiCardinalityExecutable<TType>.ExecuteAsync(IEdgeDBQueryable edgedb, CancellationToken token)
        {
            var (Query, Parameters) = Build();
            _nodes.Clear();
            _queryGlobals.Clear();
            return edgedb.QueryAsync<TType>(Query, Parameters, token);
        }
        Task<TType?> ISingleCardinalityExecutable<TType>.ExecuteAsync(IEdgeDBQueryable edgedb, CancellationToken token)
        {
            var (Query, Parameters) = Build();
            _nodes.Clear();
            _queryGlobals.Clear();
            return edgedb.QuerySingleAsync<TType>(Query, Parameters, token);
        }

        #region IQueryBuilder<TType>
        IQueryBuilder<TType> IQueryBuilder<TType>.With(string name, object? value) => With(name, value);
        #endregion
    }

    public interface IQueryBuilder<TType> : 
        IQueryBuilder, 
        ISelectQuery<TType>,
        IUpdateQuery<TType>,
        IDeleteQuery<TType>,
        IUnlessConflictOn<TType>,
        IInsertQuery<TType>
    {
        IQueryBuilder<TType> With(string name, object? value);
        ISelectQuery<TType> Select();
        ISelectQuery<TNewType> Select<TNewType>(Expression<Func<TNewType>>? shape = null);
        ISelectQuery<TType> Select(Expression<Func<QueryContext, TType?>> shape);
        ISelectQuery<TNewType> Select<TNewType>(Expression<Func<QueryContext, TNewType?>> shape);
        IInsertQuery<TType> Insert(TType value, bool returnInsertedValue = true);
        IInsertQuery<TType> Insert(Expression<Func<QueryContext, TType>> value, bool returnInsertedValue = true);
        IUpdateQuery<TType> Update(Expression<Func<TType, TType>> updateFunc, bool returnUpdatedValue = true);
        IDeleteQuery<TType> Delete { get; }
    }
    public interface IQueryBuilder
    {
        (string Query, IDictionary<string, object?> Parameters) Build();
    }
}
